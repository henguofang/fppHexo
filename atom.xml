<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>it&#39;s freedom</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.freefpp.com/"/>
  <updated>2016-05-18T03:10:19.000Z</updated>
  <id>http://www.freefpp.com/</id>
  
  <author>
    <name>方平平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java线程知识点梳理</title>
    <link href="http://www.freefpp.com/2016/05/13/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.freefpp.com/2016/05/13/线程/</id>
    <published>2016-05-13T02:55:34.000Z</published>
    <updated>2016-05-18T03:10:19.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;操作系统中线程和进程的区别&quot;&gt;&lt;a href=&quot;#操作系统中线程和进程的区别&quot; class=&quot;headerlink&quot; title=&quot;操作系统中线程和进程的区别&quot;&gt;&lt;/a&gt;操作系统中线程和进程的区别&lt;/h2&gt;&lt;p&gt;简单来说，一个程序至少有一个进程，一个进程至少有一个线程。&lt;/p&gt;
&lt;h2 id=&quot;线程的创建&quot;&gt;&lt;a href=&quot;#线程的创建&quot; class=&quot;headerlink&quot; title=&quot;线程的创建&quot;&gt;&lt;/a&gt;线程的创建&lt;/h2&gt;&lt;p&gt;继承Thread类和使用Runnable接口。&lt;/p&gt;
&lt;h4 id=&quot;方法一：继承Thread类覆盖run方法&quot;&gt;&lt;a href=&quot;#方法一：继承Thread类覆盖run方法&quot; class=&quot;headerlink&quot; title=&quot;方法一：继承Thread类覆盖run方法&quot;&gt;&lt;/a&gt;方法一：继承Thread类覆盖run方法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Demo1 {
   public static void main(String[] args) {
     Thread1 thread1=new Thread1();
     thread1.start();
     for(int i=0;i&amp;lt;60;i++){
 System.out.println(Thread.currentThread().getName()+i);
      }
   }
}
   class Thread1 extends Thread{
      @Override
      public void run() {
         for (int i = 0; i &amp;lt; 60; i++) {
   System.out.println(Thread.currentThread().getName()+i);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;方法二：继承Thread类覆盖run方法&quot;&gt;&lt;a href=&quot;#方法二：继承Thread类覆盖run方法&quot; class=&quot;headerlink&quot; title=&quot;方法二：继承Thread类覆盖run方法&quot;&gt;&lt;/a&gt;方法二：继承Thread类覆盖run方法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Demo2 {
   public static void main(String[] args){
     Thread2 d =new Thread2();
     Thread t = new Thread(d);
     t.start();
     for(int x=0;x&amp;lt;60;x++){
  System.out.println(Thread.currentThread().getName()+x);
       }
    }
}
    class Thread2 implements Runnable{
      @Override
      public void run(){
      for(int x=0;x&amp;lt;60;x++){
  System.out.println(Thread.currentThread().getName()+x);
       }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;线程的状态&quot;&gt;&lt;a href=&quot;#线程的状态&quot; class=&quot;headerlink&quot; title=&quot;线程的状态&quot;&gt;&lt;/a&gt;线程的状态&lt;/h2&gt;&lt;h4 id=&quot;一、状态&quot;&gt;&lt;a href=&quot;#一、状态&quot; class=&quot;headerlink&quot; title=&quot;一、状态&quot;&gt;&lt;/a&gt;一、状态&lt;/h4&gt;&lt;p&gt;1、新建状态(New) :创建一个线程对象。&lt;/p&gt;
&lt;p&gt;2、可运行状态(Runnable) :当线程有资格运行，但调度程度还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也可返回到可运行状态。&lt;/p&gt;
&lt;p&gt;3、运行状态(Running) :线程获取了cpu资源，执行程序代码。&lt;/p&gt;
&lt;p&gt;4、阻塞状态(Blocked) :线程因为某种原因，放弃cpu资源，暂时停止运行，当某件事件出现，可能返回可运行状态。&lt;/p&gt;
&lt;p&gt;阻塞的情况分三种 :&lt;br&gt;(一)、等待 :运行的线程执行wait()方法，JVM会把该线程放入等待池中。&lt;/p&gt;
&lt;p&gt;(二)、同步阻塞 :运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。&lt;/p&gt;
&lt;p&gt;(三)、其他阻塞 :运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。&lt;/p&gt;
&lt;p&gt;5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。&lt;/p&gt;
&lt;h4 id=&quot;二、常用函数说明&quot;&gt;&lt;a href=&quot;#二、常用函数说明&quot; class=&quot;headerlink&quot; title=&quot;二、常用函数说明&quot;&gt;&lt;/a&gt;二、常用函数说明&lt;/h4&gt;&lt;p&gt;常用的函数 :join()、join(long millis)、join(long millis, int nanos)、sleep(long millis)、sleep(long millis, int nanos)、wait()、wait(long millis)、wait(long millis,int nanos)、yield()、notify、notifyAll&lt;/p&gt;
&lt;p&gt;join()、join(long millis)、join(long millis, int nanos)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Demo3 {
   public static void main(String[] args) {
        Thread3 a=new Thread3();
        Thread3 b=new Thread3();
        a.start();
        b.start();
   }
}
class Thread3 extends Thread{
   @Override
   public void run() {
System.out.println(Thread.currentThread().getName() + &amp;quot; 线程运行开始!&amp;quot;);  
      for (int i = 0; i &amp;lt; 5; i++) {  
           System.out.println(&amp;quot;子线程&amp;quot;+Thread.currentThread().getName() + &amp;quot;运行 : &amp;quot; + i);  
        try {  
            sleep((int) Math.random() * 10);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
    System.out.println(Thread.currentThread().getName() + &amp;quot; 线程运行结束!&amp;quot;);  
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Thread-0 线程运行开始!&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-1 线程运行开始!&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-1运行 : 0&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 0&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-1运行 : 1&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 1&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 2&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-1运行 : 2&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 3&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-1运行 : 3&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 4&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-1运行 : 4&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-1 线程运行结束!&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-0 线程运行结束!&lt;/code&gt;       &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;操作系统中线程和进程的区别&quot;&gt;&lt;a href=&quot;#操作系统中线程和进程的区别&quot; class=&quot;headerlink&quot; title=&quot;操作系统中线程和进程的区别&quot;&gt;&lt;/a&gt;操作系统中线程和进程的区别&lt;/h2&gt;&lt;p&gt;简单来说，一个程序至少有一个进程，一个进程至少有一个
    
    </summary>
    
    
  </entry>
  
</feed>
