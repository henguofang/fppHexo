<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>it&#39;s freedom</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.freefpp.com/"/>
  <updated>2017-02-04T08:01:31.000Z</updated>
  <id>http://www.freefpp.com/</id>
  
  <author>
    <name>方平平</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例模式</title>
    <link href="http://www.freefpp.com/2017/02/04/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.freefpp.com/2017/02/04/单例模式/</id>
    <published>2017-02-04T06:47:20.000Z</published>
    <updated>2017-02-04T08:01:31.000Z</updated>
    
    <content type="html">&lt;p&gt;##单例模式&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/cselmu9/article/details/51366946&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个写的很好&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在所有的设计模式中，单例模式是我们在项目开发中最为常见的设计模式之一，而单例模式有很多种实现方式，你是否都了解呢？高并发下如何保证单例模式的线程安全性呢？如何保证序列化后的单例对象在反序列化后任然是单例的呢？这些问题在看了本文之后都会一一的告诉你答案，赶快来阅读吧！&lt;br&gt;什么是单例模式?&lt;br&gt;在文章开始之前我们还是有必要介绍一下什么是单例模式。单例模式是为确保一个类只有一个实例，并为整个系统提供一个全局访问点的一种模式方法。&lt;br&gt;从概念中体现出了单例的一些特点：&lt;br&gt;（1）、在任何情况下，单例类永远只有一个实例存在&lt;br&gt;（2）、单例需要有能力为整个系统提供这一唯一实例  &lt;/p&gt;
&lt;p&gt;  为了便于读者更好的理解这些概念，下面给出这么一段内容叙述：&lt;br&gt;在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。&lt;/p&gt;
&lt;p&gt;正是由于这个特点，单例对象通常作为程序中的存放配置信息的载体，因为它能保证其他对象读到一致的信息。例如在某个服务器程序中，该服务器的配置信息可能存放在数据库或文件中，这些配置数据由某个单例对象统一读取，服务进程中的其他对象如果要获取这些配置信息，只需访问该单例对象即可。这种方式极大地简化了在复杂环境 下，尤其是多线程环境下的配置管理，但是随着应用场景的不同，也可能带来一些同步问题。&lt;/p&gt;
&lt;p&gt;各式各样的单例实现&lt;br&gt;温馨提示：本文叙述中涉及到的相关源码可以在这里进行下载源码，读者可免积分下载。&lt;br&gt;1、饿汉式单例&lt;br&gt;饿汉式单例是指在方法调用前，实例就已经创建好了。下面是实现代码：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.mlinge.s01;  

public class MySingleton {  

private static MySingleton instance = new MySingleton();  

private MySingleton(){}  

public static MySingleton getInstance() {  
    return instance;  
}  

}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上是单例的饿汉式实现，我们来看看饿汉式在多线程下的执行情况，给出一段多线程的执行代码：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.mlinge.s01;  

public class MyThread extends Thread{  

@Override  
public void run() {   
    System.out.println(MySingleton.getInstance().hashCode());  
}  

public static void main(String[] args) {   

    MyThread[] mts = new MyThread[10];  
    for(int i = 0 ; i &amp;lt; mts.length ; i++){  
        mts[i] = new MyThread();  
    }  

    for (int j = 0; j &amp;lt; mts.length; j++) {  
        mts[j].start();  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;以上代码运行结果：&lt;br&gt;[plain] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954  &lt;/p&gt;
&lt;p&gt;从运行结果可以看出实例变量额hashCode值一致，这说明对象是同一个，饿汉式单例实现了。&lt;br&gt;2、懒汉式单例&lt;br&gt;懒汉式单例是指在方法调用获取实例时才创建实例，因为相对饿汉式显得“不急迫”，所以被叫做“懒汉模式”。下面是实现代码：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.mlinge.s02;  

public class MySingleton {  

private static MySingleton instance = null;  

private MySingleton(){}  

public static MySingleton getInstance() {  
    if(instance == null){//懒汉式  
        instance = new MySingleton();  
    }  
    return instance;  
}  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里实现了懒汉式的单例，但是熟悉多线程并发编程的朋友应该可以看出，在多线程并发下这样的实现是无法保证实例实例唯一的，甚至可以说这样的失效是完全错误的，下面我们就来看一下多线程并发下的执行情况，这里为了看到效果，我们对上面的代码做一小点修改：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.mlinge.s02;  

public class MySingleton {  

private static MySingleton instance = null;  

private MySingleton(){}  

public static MySingleton getInstance() {  
    try {   
        if(instance != null){//懒汉式   

        }else{  
            //创建实例之前可能会有一些准备性的耗时工作   
            Thread.sleep(300);  
            instance = new MySingleton();  
        }  
    } catch (InterruptedException e) {   
        e.printStackTrace();  
    }  
    return instance;  
}  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里假设在创建实例前有一些准备性的耗时工作要处理，多线程调用：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.mlinge.s02;  

public class MyThread extends Thread{  

@Override  
public void run() {   
    System.out.println(MySingleton.getInstance().hashCode());  
}  

public static void main(String[] args) {   

    MyThread[] mts = new MyThread[10];  
    for(int i = 0 ; i &amp;lt; mts.length ; i++){  
        mts[i] = new MyThread();  
    }  

    for (int j = 0; j &amp;lt; mts.length; j++) {  
        mts[j].start();  
    }  
}  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果如下：&lt;br&gt;[plain] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;1210420568&lt;br&gt;1210420568&lt;br&gt;1935123450&lt;br&gt;1718900954&lt;br&gt;1481297610&lt;br&gt;1863264879&lt;br&gt;369539795&lt;br&gt;1210420568&lt;br&gt;1210420568&lt;br&gt;602269801  &lt;/p&gt;
&lt;p&gt;从这里执行结果可以看出，单例的线程安全性并没有得到保证，那要怎么解决呢？&lt;br&gt;3、线程安全的懒汉式单例&lt;br&gt;要保证线程安全，我们就得需要使用同步锁机制，下面就来看看我们如何一步步的解决 存在线程安全问题的懒汉式单例（错误的单例）。&lt;br&gt;（1）、 方法中声明synchronized关键字&lt;br&gt;出现非线程安全问题，是由于多个线程可以同时进入getInstance()方法，那么只需要对该方法进行synchronized的锁同步即可：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.mlinge.s03;  

public class MySingleton {  

private static MySingleton instance = null;  

private MySingleton(){}  

public synchronized static MySingleton getInstance() {  
    try {   
        if(instance != null){//懒汉式   

        }else{  
            //创建实例之前可能会有一些准备性的耗时工作   
            Thread.sleep(300);  
            instance = new MySingleton();  
        }  
    } catch (InterruptedException e) {   
        e.printStackTrace();  
    }  
    return instance;  
}  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时任然使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入到org.mlinge.s03包下运行，执行结果如下：&lt;br&gt;[plain] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;1689058373&lt;br&gt;1689058373&lt;br&gt;1689058373&lt;br&gt;1689058373&lt;br&gt;1689058373&lt;br&gt;1689058373&lt;br&gt;1689058373&lt;br&gt;1689058373&lt;br&gt;1689058373&lt;br&gt;1689058373&lt;br&gt;从执行结果上来看，问题已经解决了，但是这种实现方式的运行效率会很低。同步方法效率低，那我们考虑使用同步代码块来实现：&lt;br&gt;（2）、 同步代码块实现&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.mlinge.s03;  

public class MySingleton {  

private static MySingleton instance = null;  

private MySingleton(){}  

//public synchronized static MySingleton getInstance() {  
public static MySingleton getInstance() {  
    try {   
        synchronized (MySingleton.class) {  
            if(instance != null){//懒汉式   

            }else{  
                //创建实例之前可能会有一些准备性的耗时工作   
                Thread.sleep(300);  
                instance = new MySingleton();  
            }  
        }  
    } catch (InterruptedException e) {   
        e.printStackTrace();  
    }  
    return instance;  
}  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的实现能够保证多线程并发下的线程安全性，但是这样的实现将全部的代码都被锁上了，同样的效率很低下。&lt;br&gt;（3）、 针对某些重要的代码来进行单独的同步（可能非线程安全）&lt;br&gt;针对某些重要的代码进行单独的同步，而不是全部进行同步，可以极大的提高执行效率，我们来看一下：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.mlinge.s04;  

public class MySingleton {  

private static MySingleton instance = null;  

private MySingleton(){}  

public static MySingleton getInstance() {  
    try {    
        if(instance != null){//懒汉式   

        }else{  
            //创建实例之前可能会有一些准备性的耗时工作   
            Thread.sleep(300);  
            synchronized (MySingleton.class) {  
                instance = new MySingleton();  
            }  
        }   
    } catch (InterruptedException e) {   
        e.printStackTrace();  
    }  
    return instance;  
}  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时同样使用前面验证多线程下执行情况的MyThread类来进行验证，将其放入到org.mlinge.s04包下运行，执行结果如下：&lt;br&gt;[plain] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;1481297610&lt;br&gt;397630378&lt;br&gt;1863264879&lt;br&gt;1210420568&lt;br&gt;1935123450&lt;br&gt;369539795&lt;br&gt;590202901&lt;br&gt;1718900954&lt;br&gt;1689058373&lt;br&gt;602269801&lt;br&gt;从运行结果来看，这样的方法进行代码块同步，代码的运行效率是能够得到提升，但是却没能保住线程的安全性。看来还得进一步考虑如何解决此问题。&lt;br&gt;（4）、 Double Check Locking 双检查锁机制（推荐）&lt;br&gt;为了达到线程安全，又能提高代码执行效率，我们这里可以采用DCL的双检查锁机制来完成，代码实现如下：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.mlinge.s05;  

public class MySingleton {  

//使用volatile关键字保其可见性  
volatile private static MySingleton instance = null;  

private MySingleton(){}  

public static MySingleton getInstance() {  
    try {    
        if(instance != null){//懒汉式   

        }else{  
            //创建实例之前可能会有一些准备性的耗时工作   
            Thread.sleep(300);  
            synchronized (MySingleton.class) {  
                if(instance == null){//二次检查  
                    instance = new MySingleton();  
                }  
            }  
        }   
    } catch (InterruptedException e) {   
        e.printStackTrace();  
    }  
    return instance;  
}  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将前面验证多线程下执行情况的MyThread类放入到org.mlinge.s05包下运行，执行结果如下：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;369539795&lt;br&gt;369539795&lt;br&gt;369539795&lt;br&gt;369539795&lt;br&gt;369539795&lt;br&gt;369539795&lt;br&gt;369539795&lt;br&gt;369539795&lt;br&gt;369539795&lt;br&gt;369539795&lt;br&gt;从运行结果来看，该中方法保证了多线程并发下的线程安全性。&lt;br&gt;这里在声明变量时使用了volatile关键字来保证其线程间的可见性；在同步代码块中使用二次检查，以保证其不被重复实例化。集合其二者，这种实现方式既保证了其高效性，也保证了其线程安全性。&lt;br&gt;4、使用静态内置类实现单例模式&lt;br&gt;DCL解决了多线程并发下的线程安全问题，其实使用其他方式也可以达到同样的效果，代码实现如下：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.mlinge.s06;  

public class MySingleton {  

//内部类  
private static class MySingletonHandler{  
    private static MySingleton instance = new MySingleton();  
}   

private MySingleton(){}  

public static MySingleton getInstance() {   
    return MySingletonHandler.instance;  
}  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上代码就是使用静态内置类实现了单例模式，这里将前面验证多线程下执行情况的MyThread类放入到org.mlinge.s06包下运行，执行结果如下：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;从运行结果来看，静态内部类实现的单例在多线程并发下单个实例得到了保证。&lt;br&gt;5、序列化与反序列化的单例模式实现&lt;br&gt;静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的。&lt;br&gt;代码实现如下：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.mlinge.s07;  

import java.io.Serializable;  

 public class MySingleton implements Serializable {  

private static final long serialVersionUID = 1L;  

//内部类  
private static class MySingletonHandler{  
    private static MySingleton instance = new MySingleton();  
}   

private MySingleton(){}  

public static MySingleton getInstance() {   
    return MySingletonHandler.instance;  
}  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;序列化与反序列化测试代码：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; package org.mlinge.s07;  

import java.io.File;  
import java.io.FileInputStream;  
import java.io.FileNotFoundException;  
import java.io.FileOutputStream;  
import java.io.IOException;  
import java.io.ObjectInputStream;  
import java.io.ObjectOutputStream;  

public class SaveAndReadForSingleton {  

public static void main(String[] args) {  
    MySingleton singleton = MySingleton.getInstance();  

    File file = new File(&amp;quot;MySingleton.txt&amp;quot;);  

    try {  
        FileOutputStream fos = new FileOutputStream(file);  
        ObjectOutputStream oos = new ObjectOutputStream(fos);  
        oos.writeObject(singleton);  
        fos.close();  
        oos.close();  
        System.out.println(singleton.hashCode());  
    } catch (FileNotFoundException e) {   
        e.printStackTrace();  
    } catch (IOException e) {   
        e.printStackTrace();  
    }  

    try {  
        FileInputStream fis = new FileInputStream(file);  
        ObjectInputStream ois = new ObjectInputStream(fis);  
        MySingleton rSingleton = (MySingleton) ois.readObject();  
        fis.close();  
        ois.close();  
        System.out.println(rSingleton.hashCode());  
    } catch (FileNotFoundException e) {   
        e.printStackTrace();  
    } catch (IOException e) {   
        e.printStackTrace();  
    } catch (ClassNotFoundException e) {   
        e.printStackTrace();  
    }  

}  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行以上代码，得到的结果如下：&lt;br&gt;[sql] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;865113938&lt;br&gt;1442407170&lt;br&gt;从结果中我们发现，序列号对象的hashCode和反序列化后得到的对象的hashCode值不一样，说明反序列化后返回的对象是重新实例化的，单例被破坏了。那怎么来解决这一问题呢？&lt;br&gt;解决办法就是在反序列化的过程中使用readResolve()方法，单例实现的代码如下：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;package org.mlinge.s07;  &lt;/p&gt;
&lt;p&gt;import java.io.ObjectStreamException;&lt;br&gt;import java.io.Serializable;  &lt;/p&gt;
&lt;p&gt;public class MySingleton implements Serializable {  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static final long serialVersionUID = 1L;  

//内部类  
private static class MySingletonHandler{  
    private static MySingleton instance = new MySingleton();  
}   

private MySingleton(){}  

public static MySingleton getInstance() {   
    return MySingletonHandler.instance;  
}  

//该方法在反序列化时会被调用，该方法不是接口定义的方法，有点儿约定俗成的感觉  
protected Object readResolve() throws ObjectStreamException {  
    System.out.println(&amp;quot;调用了readResolve方法！&amp;quot;);  
    return MySingletonHandler.instance;   
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;再次运行上面的测试代码，得到的结果如下：&lt;br&gt;[plain] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;865113938&lt;br&gt;调用了readResolve方法！&lt;br&gt;865113938&lt;br&gt;从运行结果可知，添加readResolve方法后反序列化后得到的实例和序列化前的是同一个实例，单个实例得到了保证。&lt;br&gt;6、使用static代码块实现单例&lt;br&gt;静态代码块中的代码在使用类的时候就已经执行了，所以可以应用静态代码块的这个特性的实现单例设计模式。&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;package org.mlinge.s08;  &lt;/p&gt;
&lt;p&gt;public class MySingleton{  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static MySingleton instance = null;  

private MySingleton(){}  

static{  
    instance = new MySingleton();  
}  

public static MySingleton getInstance() {   
    return instance;  
}   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;测试代码如下：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;package org.mlinge.s08;  &lt;/p&gt;
&lt;p&gt;public class MyThread extends Thread{  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override  
public void run() {   
    for (int i = 0; i &amp;lt; 5; i++) {  
        System.out.println(MySingleton.getInstance().hashCode());  
    }  
}  

public static void main(String[] args) {   

    MyThread[] mts = new MyThread[3];  
    for(int i = 0 ; i &amp;lt; mts.length ; i++){  
        mts[i] = new MyThread();  
    }  

    for (int j = 0; j &amp;lt; mts.length; j++) {  
        mts[j].start();  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;运行结果如下：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;1718900954&lt;br&gt;从运行结果看，单例的线程安全性得到了保证。&lt;br&gt;7、使用枚举数据类型实现单例模式&lt;br&gt;枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;package org.mlinge.s09;  &lt;/p&gt;
&lt;p&gt;public enum EnumFactory{   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;singletonFactory;  

private MySingleton instance;  

private EnumFactory(){//枚举类的构造方法在类加载是被实例化  
    instance = new MySingleton();  
}  

public MySingleton getInstance(){  
    return instance;  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}  &lt;/p&gt;
&lt;p&gt;class MySingleton{//需要获实现单例的类，比如数据库连接Connection&lt;br&gt;    public MySingleton(){}&lt;br&gt;}&lt;br&gt;测试代码如下：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;package org.mlinge.s09;  &lt;/p&gt;
&lt;p&gt;public class MyThread extends Thread{  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override  
public void run() {   
    System.out.println(EnumFactory.singletonFactory.getInstance().hashCode());  
}  

public static void main(String[] args) {   

    MyThread[] mts = new MyThread[10];  
    for(int i = 0 ; i &amp;lt; mts.length ; i++){  
        mts[i] = new MyThread();  
    }  

    for (int j = 0; j &amp;lt; mts.length; j++) {  
        mts[j].start();  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;执行后得到的结果：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;1481297610&lt;br&gt;1481297610&lt;br&gt;1481297610&lt;br&gt;1481297610&lt;br&gt;1481297610&lt;br&gt;1481297610&lt;br&gt;1481297610&lt;br&gt;1481297610&lt;br&gt;1481297610&lt;br&gt;1481297610&lt;br&gt;运行结果表明单例得到了保证，但是这样写枚举类被完全暴露了，据说违反了“职责单一原则”，那我们来看看怎么进行改造呢。&lt;br&gt;8、完善使用enum枚举实现单例模式&lt;br&gt;不暴露枚举类实现细节的封装代码如下：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;package org.mlinge.s10;  &lt;/p&gt;
&lt;p&gt;public class ClassFactory{   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private enum MyEnumSingleton{  
    singletonFactory;  

    private MySingleton instance;  

    private MyEnumSingleton(){//枚举类的构造方法在类加载是被实例化  
        instance = new MySingleton();  
    }  

    public MySingleton getInstance(){  
        return instance;  
    }  
}   

public static MySingleton getInstance(){  
    return MyEnumSingleton.singletonFactory.getInstance();  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}  &lt;/p&gt;
&lt;p&gt;class MySingleton{//需要获实现单例的类，比如数据库连接Connection&lt;br&gt;    public MySingleton(){}&lt;br&gt;}&lt;br&gt;验证单例实现的代码如下：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;package org.mlinge.s10;  &lt;/p&gt;
&lt;p&gt;public class MyThread extends Thread{  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override  
public void run() {   
    System.out.println(ClassFactory.getInstance().hashCode());  
}  

public static void main(String[] args) {   

    MyThread[] mts = new MyThread[10];  
    for(int i = 0 ; i &amp;lt; mts.length ; i++){  
        mts[i] = new MyThread();  
    }  

    for (int j = 0; j &amp;lt; mts.length; j++) {  
        mts[j].start();  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;验证结果：&lt;br&gt;[java] view plain copy print?在CODE上查看代码片派生到我的代码片&lt;br&gt;1935123450&lt;br&gt;1935123450&lt;br&gt;1935123450&lt;br&gt;1935123450&lt;br&gt;1935123450&lt;br&gt;1935123450&lt;br&gt;1935123450&lt;br&gt;1935123450&lt;br&gt;1935123450&lt;br&gt;1935123450&lt;br&gt;验证结果表明，完善后的单例实现更为合理。&lt;br&gt;以上就是本文要介绍的所有单例模式的实现，相信认真阅读的读者都已经明白文章开头所引入的那几个问题了，祝大家读得开心:-D！&lt;/p&gt;
&lt;p&gt;备注：本文的编写思路和实例源码参照《Java多线程编程核心技术》-（高洪岩）一书中第六章的学习案例撰写。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##单例模式&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/cselmu9/article/details/51366946&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个写的很好&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在所有的设计模式中，单例模式
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://www.freefpp.com/2017/02/04/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.freefpp.com/2017/02/04/工厂模式/</id>
    <published>2017-02-04T03:09:34.000Z</published>
    <updated>2017-02-04T06:19:41.000Z</updated>
    
    <content type="html">&lt;p&gt;##简单工厂模式&lt;br&gt;  简单工厂模式又称静态工厂方法模式。定义产品对象的接口，然后实现，最后用工厂类调用。&lt;br&gt;  工厂类决定哪一个产品被实例化，如同一个交通警察站在来往的车辆流中，决定放行哪一个方向的车辆向哪一个方向流动一样。&lt;br&gt;  1)工厂类角色：本模式的商业逻辑和判断逻辑，在java中一个具体类的实现，静态方法。&lt;br&gt;  2）抽象产品角色：一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类实现。&lt;br&gt;  3）具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。&lt;/p&gt;
&lt;p&gt;##工厂模式&lt;br&gt;  工厂模式里不再只有一个工厂决定哪一个产品类应当被实例化，这个决定交给抽象类的子类去做。&lt;br&gt;  1）抽象工厂角色：这是工厂方法模式的核心，是具体工厂角色必须实现的接口或者必须继承的父类。&lt;br&gt;  2）具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。&lt;br&gt;  3）抽象产品角色。&lt;br&gt;  4）具体产品角色。&lt;br&gt;  //抽象产品角色     &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                                                                                                             public interface Moveable {
void run();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//具体产品角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Plane implements Moveable {
@Override
public void run() {
    System.out.println(&amp;quot;plane....&amp;quot;);
}
}

public class Broom implements Moveable {
@Override
public void run() {
    System.out.println(&amp;quot;broom.....&amp;quot;);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//抽象工厂&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public abstract class VehicleFactory {
    abstract Moveable create();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//具体工厂&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PlaneFactory extends VehicleFactory{
    public Moveable create() {
        return new Plane();
    }
}
public class BroomFactory extends VehicleFactory{
    public Moveable create() {
        return new Broom();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//测试类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String[] args) {
        VehicleFactory factory = new BroomFactory();
        Moveable m = factory.create();
        m.run();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##抽象工厂模式&lt;br&gt;抽象产品可能是一个或多个，从而构成一个或多个产品族。在只有一个产品族的情况下，抽象工厂模式实际上退化到工厂方法模式。  &lt;/p&gt;
&lt;p&gt;//抽象工厂类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class AbstractFactory {
    public abstract Vehicle createVehicle();
    public abstract Weapon createWeapon();
    public abstract Food createFood();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//具体工厂类，其中Food,Vehicle，Weapon是抽象类，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class DefaultFactory extends AbstractFactory{
    @Override
     public Food createFood() {
        return new Apple();
    }
    @Override
    public Vehicle createVehicle() {
        return new Car();
    }
    @Override
    public Weapon createWeapon() {
        return new AK47();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//测试类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String[] args) {
        AbstractFactory f = new DefaultFactory();
        Vehicle v = f.createVehicle();
        v.run();
        Weapon w = f.createWeapon();
        w.shoot();
        Food a = f.createFood();
        a.printName();
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##总结&lt;br&gt;（1）简单工厂模式是由一个具体的类去创建其他类的实例，父类是相同的，父类是具体的。&lt;br&gt;（2）工厂方法模式是有一个抽象的父类定义公共接口，子类负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成。&lt;br&gt;（3）抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。它针对的是有多个产品的等级结构。而工厂方法模式针对的是一个产品的等级结构。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##简单工厂模式&lt;br&gt;  简单工厂模式又称静态工厂方法模式。定义产品对象的接口，然后实现，最后用工厂类调用。&lt;br&gt;  工厂类决定哪一个产品被实例化，如同一个交通警察站在来往的车辆流中，决定放行哪一个方向的车辆向哪一个方向流动一样。&lt;br&gt;  1)工厂类角色：本模式的商业
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>业余兴趣爱好</title>
    <link href="http://www.freefpp.com/2017/01/28/100KM%E8%A1%8C%E5%8A%A8%E8%AE%A1%E5%88%92%E4%B9%A6/"/>
    <id>http://www.freefpp.com/2017/01/28/100KM行动计划书/</id>
    <published>2017-01-28T01:04:58.000Z</published>
    <updated>2017-01-28T09:13:37.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;业余兴趣爱好&quot;&gt;&lt;a href=&quot;#业余兴趣爱好&quot; class=&quot;headerlink&quot; title=&quot;业余兴趣爱好&quot;&gt;&lt;/a&gt;业余兴趣爱好&lt;/h2&gt;&lt;p&gt;现在是2017年1月28日大年初一，我期望我能在未来的一年里（即2018/1/28），能完成我心中的一个兴趣目标。&lt;br&gt;1、铁人三项&lt;br&gt;2、100km越野跑&lt;br&gt;3、1000km著名路线骑行&lt;br&gt;三者中的一个就行。&lt;/p&gt;
&lt;h2 id=&quot;计划&quot;&gt;&lt;a href=&quot;#计划&quot; class=&quot;headerlink&quot; title=&quot;计划&quot;&gt;&lt;/a&gt;计划&lt;/h2&gt;&lt;p&gt;1、每天7点跑步5－10km或1000m不间断游泳🏊，周末进行lsd拉练（15km以上）。&lt;br&gt;2、核心训练练习。&lt;br&gt;3、饮食，注意不喝碳酸饮料，不吃油炸食品，不吃冰淇淋。&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;该计划如要实现，需本人切实的进行锻炼，不可惰，不可将就。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;业余兴趣爱好&quot;&gt;&lt;a href=&quot;#业余兴趣爱好&quot; class=&quot;headerlink&quot; title=&quot;业余兴趣爱好&quot;&gt;&lt;/a&gt;业余兴趣爱好&lt;/h2&gt;&lt;p&gt;现在是2017年1月28日大年初一，我期望我能在未来的一年里（即2018/1/28），能完成我心中的一个兴趣
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://www.freefpp.com/2016/10/31/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.freefpp.com/2016/10/31/观察者模式/</id>
    <published>2016-10-31T01:55:10.000Z</published>
    <updated>2016-10-31T02:38:15.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h2&gt;&lt;p&gt;观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，让他们能够自动更新自己。&lt;/p&gt;
&lt;h2 id=&quot;观察者模式的组成&quot;&gt;&lt;a href=&quot;#观察者模式的组成&quot; class=&quot;headerlink&quot; title=&quot;观察者模式的组成&quot;&gt;&lt;/a&gt;观察者模式的组成&lt;/h2&gt;&lt;p&gt;抽象主题角色：把所有对观察者对象的引用保存在一个集合中，每个抽象主题角色都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般性用一个抽象类和借口来实现。&lt;br&gt;抽象观察者角色：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h2&gt;&lt;p&gt;观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://www.freefpp.com/2016/10/21/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.freefpp.com/2016/10/21/策略模式/</id>
    <published>2016-10-21T06:43:54.000Z</published>
    <updated>2016-10-21T06:50:40.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h2&gt;&lt;p&gt;策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h2&gt;&lt;p&gt;策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>spring mvc知识点梳理</title>
    <link href="http://www.freefpp.com/2016/05/25/spring-mvc%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <id>http://www.freefpp.com/2016/05/25/spring-mvc知识点梳理/</id>
    <published>2016-05-25T00:49:20.000Z</published>
    <updated>2016-05-26T05:59:30.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;MVC框架是什么&quot;&gt;&lt;a href=&quot;#MVC框架是什么&quot; class=&quot;headerlink&quot; title=&quot;MVC框架是什么&quot;&gt;&lt;/a&gt;MVC框架是什么&lt;/h2&gt;&lt;p&gt;全名是Model View Controller,是模型(model)-视图(view)-控制器(controller)的缩写,一种软件设计典范,用一种业务逻辑、数据、界面显示分离的方法组织代码。&lt;/p&gt;
&lt;p&gt;Spring MVC应用程序中，模型通常由pojo对象组成，它在业务层被处理，在持久层中被持久化。视图通常是用jsp标准标签库编写的jsp模版。控制器部分是由dispatcher servlet负责。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MVC框架是什么&quot;&gt;&lt;a href=&quot;#MVC框架是什么&quot; class=&quot;headerlink&quot; title=&quot;MVC框架是什么&quot;&gt;&lt;/a&gt;MVC框架是什么&lt;/h2&gt;&lt;p&gt;全名是Model View Controller,是模型(model)-视图(view)-控
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java集合知识点梳理</title>
    <link href="http://www.freefpp.com/2016/05/24/java%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <id>http://www.freefpp.com/2016/05/24/java集合知识点梳理/</id>
    <published>2016-05-24T12:39:23.000Z</published>
    <updated>2016-07-14T02:21:52.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见的面试题</title>
    <link href="http://www.freefpp.com/2016/05/24/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://www.freefpp.com/2016/05/24/常见的面试题/</id>
    <published>2016-05-24T11:36:18.000Z</published>
    <updated>2016-05-24T11:45:58.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java基础知识点梳理</title>
    <link href="http://www.freefpp.com/2016/05/18/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <id>http://www.freefpp.com/2016/05/18/java基础知识点梳理/</id>
    <published>2016-05-18T09:23:19.000Z</published>
    <updated>2016-05-24T12:27:25.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h2&gt;&lt;p&gt;1) 在每个类文件中最多只允许出现一个public类&lt;/p&gt;
&lt;p&gt;2) 如果没有显示地定义构造器，则编译器会自动创建一个无参构造器，如果显示地定义了构造器，编译器就不会自动添加构造器。注意，所有的构造器默认为static的。&lt;/p&gt;
&lt;p&gt;3) 初始化顺序&lt;br&gt;static成员变量和static语句块—–&amp;gt;对象的成员变量(先初始化)—–&amp;gt;构造器&lt;/p&gt;
&lt;p&gt;4) 子类是不能够继承父类的构造器，但是要注意的是，如果父类的构造器都是带有参数的，则必须在子类的构造器中显示地通过super关键字调用父类的构造器并配以适当的参数列表。如果父类有无参构造器，则在子类的构造器中用super关键字调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。&lt;/p&gt;
&lt;h2 id=&quot;继承与多态&quot;&gt;&lt;a href=&quot;#继承与多态&quot; class=&quot;headerlink&quot; title=&quot;继承与多态&quot;&gt;&lt;/a&gt;继承与多态&lt;/h2&gt;&lt;p&gt;覆盖只针对非静态方法（终态方法不能被继承，所以就存在覆盖一说了），而隐藏是针对成员变量和静态方法的。这2者之间的区别是：覆盖受RTTI（Runtime type  identification）约束的，而隐藏却不受该约束。也就是说只有覆盖方法才会进行动态绑定，而隐藏是不会发生动态绑定的。在Java中，除了static方法和final方法，其他所有的方法都是动态绑定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Demo8 {
    public static void main(String[] args)  {
        Shape shape = new Circle();
        System.out.println(shape.name);
        shape.printType();
        shape.printName();
    }
}

class Shape {
    public String name = &amp;quot;shape&amp;quot;;

    public Shape(){
        System.out.println(&amp;quot;shape constructor&amp;quot;);
    }

    public void printType() {
        System.out.println(&amp;quot;this is shape&amp;quot;);
    }

    public static void printName() {
        System.out.println(&amp;quot;shape&amp;quot;);
    }
}

class Circle extends Shape {
    public  String name = &amp;quot;circle&amp;quot;;

    public Circle() {
        System.out.println(&amp;quot;circle constructor&amp;quot;);
    }

    public void printType() {
        System.out.println(&amp;quot;this is circle&amp;quot;);
    }

    public static void printName() {
        System.out.println(&amp;quot;circle&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;shape constructor&lt;/code&gt;&lt;br&gt;&lt;code&gt;circle constructor&lt;/code&gt;&lt;br&gt;&lt;code&gt;shape&lt;/code&gt;&lt;br&gt;&lt;code&gt;this is circle&lt;/code&gt;&lt;br&gt;&lt;code&gt;shape&lt;/code&gt;      &lt;/p&gt;
&lt;h3 id=&quot;什么是多态&quot;&gt;&lt;a href=&quot;#什么是多态&quot; class=&quot;headerlink&quot; title=&quot;什么是多态&quot;&gt;&lt;/a&gt;什么是多态&lt;/h3&gt;&lt;p&gt;下面是网上看到的一篇文章，写的很棒&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/jack204/archive/2012/10/29/2745150.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;  &lt;/p&gt;
&lt;h4 id=&quot;Java中多态性的实现&quot;&gt;&lt;a href=&quot;#Java中多态性的实现&quot; class=&quot;headerlink&quot; title=&quot;Java中多态性的实现&quot;&gt;&lt;/a&gt;Java中多态性的实现&lt;/h4&gt;&lt;h4 id=&quot;什么是多态-1&quot;&gt;&lt;a href=&quot;#什么是多态-1&quot; class=&quot;headerlink&quot; title=&quot;什么是多态&quot;&gt;&lt;/a&gt;什么是多态&lt;/h4&gt;&lt;p&gt;面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。    &lt;/p&gt;
&lt;p&gt;多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）&lt;br&gt;实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 &lt;/p&gt;
&lt;h4 id=&quot;多态的作用：消除类型之间的耦合关系。&quot;&gt;&lt;a href=&quot;#多态的作用：消除类型之间的耦合关系。&quot; class=&quot;headerlink&quot; title=&quot;多态的作用：消除类型之间的耦合关系。&quot;&gt;&lt;/a&gt;多态的作用：消除类型之间的耦合关系。&lt;/h4&gt;&lt;p&gt;现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。&lt;br&gt;下面是多态存在的三个必要条件，要求大家做梦时都能背出来！&lt;/p&gt;
&lt;h4 id=&quot;多态存在的三个必要条件&quot;&gt;&lt;a href=&quot;#多态存在的三个必要条件&quot; class=&quot;headerlink&quot; title=&quot;多态存在的三个必要条件&quot;&gt;&lt;/a&gt;多态存在的三个必要条件&lt;/h4&gt;&lt;p&gt;一、要有继承；&lt;br&gt;二、要有重写；&lt;br&gt;三、父类引用指向子类对象。&lt;/p&gt;
&lt;h4 id=&quot;多态的好处：&quot;&gt;&lt;a href=&quot;#多态的好处：&quot; class=&quot;headerlink&quot; title=&quot;多态的好处：&quot;&gt;&lt;/a&gt;多态的好处：&lt;/h4&gt;&lt;p&gt;1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。&lt;br&gt;2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。&lt;br&gt;3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。&lt;br&gt;4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。&lt;br&gt;5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。&lt;/p&gt;
&lt;p&gt;Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。        &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Demo11 {
    public static void main(String[] args) {
        A a1 = new A();  
        A a2 = new B();  
        B b = new B();  
        C c = new C();   
        D d = new D();  
        System.out.println(a1.show(b));     
        System.out.println(a1.show(c));   
        System.out.println(a1.show(d));   
        System.out.println(a2.show(b));    
        System.out.println(a2.show(c));    
        System.out.println(a2.show(d));    
        System.out.println(b.show(b));    
        System.out.println(b.show(c));      
        System.out.println(b.show(d));   
    }

}
class A {  
    public String show(D obj){  
           return (&amp;quot;A and D&amp;quot;);  
    }   
    public String show(A obj){  
           return (&amp;quot;A and A&amp;quot;);  
    }   
}   
class B extends A{  
    public String show(B obj){  
           return (&amp;quot;B and B&amp;quot;);  
    }  
    public String show(A obj){  
           return (&amp;quot;B and A&amp;quot;);  
    }   
}  
class C extends B{}   
class D extends B{}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;A and A&lt;/code&gt;&lt;br&gt;&lt;code&gt;A and A&lt;/code&gt;&lt;br&gt;&lt;code&gt;A and D&lt;/code&gt;&lt;br&gt;&lt;code&gt;B and A&lt;/code&gt;&lt;br&gt;&lt;code&gt;B and A&lt;/code&gt;&lt;br&gt;&lt;code&gt;A and D&lt;/code&gt;&lt;br&gt;&lt;code&gt;B and B&lt;/code&gt;&lt;br&gt;&lt;code&gt;B and B&lt;/code&gt;&lt;br&gt;&lt;code&gt;A and D&lt;/code&gt;        &lt;/p&gt;
&lt;h2 id=&quot;static静态&quot;&gt;&lt;a href=&quot;#static静态&quot; class=&quot;headerlink&quot; title=&quot;static静态&quot;&gt;&lt;/a&gt;static静态&lt;/h2&gt;&lt;p&gt;1) static 方法&lt;br&gt;由于静态方法不依赖于任何对象就可以访问，因此是没有this的，在静态方法中不能访问类的非静态成员变量和非静态成员方法，但是在非静态成员方法中是可以访问静态成员方法/变量的。&lt;/p&gt;
&lt;p&gt;2) static 变量&lt;/p&gt;
&lt;p&gt;3) static 代码块&lt;br&gt;形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。&lt;/p&gt;
&lt;h4 id=&quot;能通过this访问静态成员变量吗？&quot;&gt;&lt;a href=&quot;#能通过this访问静态成员变量吗？&quot; class=&quot;headerlink&quot; title=&quot;能通过this访问静态成员变量吗？&quot;&gt;&lt;/a&gt;能通过this访问静态成员变量吗？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Main {　　
    static int value = 33;

    public static void main(String[] args) throws         Exception{
        new Main().printValue();
    }

    private void printValue(){
        int value = 3;
        System.out.println(this.value);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;33&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;下面这段代码的输出结果是什么？&quot;&gt;&lt;a href=&quot;#下面这段代码的输出结果是什么？&quot; class=&quot;headerlink&quot; title=&quot;下面这段代码的输出结果是什么？&quot;&gt;&lt;/a&gt;下面这段代码的输出结果是什么？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Test extends Base{

    static{
        System.out.println(&amp;quot;test static&amp;quot;);
    }

    public Test(){
        System.out.println(&amp;quot;test constructor&amp;quot;);
    }

    public static void main(String[] args) {
        new Test();
    }
}

    class Base{

    static{
        System.out.println(&amp;quot;base static&amp;quot;);
    }

    public Base(){
        System.out.println(&amp;quot;base constructor&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;base static&lt;/code&gt;&lt;br&gt;&lt;code&gt;test static&lt;/code&gt;&lt;br&gt;&lt;code&gt;base constructor&lt;/code&gt;&lt;br&gt;&lt;code&gt;test constructor&lt;/code&gt;         &lt;/p&gt;
&lt;h4 id=&quot;这段代码的输出结果是什么？&quot;&gt;&lt;a href=&quot;#这段代码的输出结果是什么？&quot; class=&quot;headerlink&quot; title=&quot;这段代码的输出结果是什么？&quot;&gt;&lt;/a&gt;这段代码的输出结果是什么？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Test {
    Person person = new Person(&amp;quot;Test&amp;quot;);
    static{
        System.out.println(&amp;quot;test static&amp;quot;);
    }

    public Test() {
        System.out.println(&amp;quot;test constructor&amp;quot;);
    }

    public static void main(String[] args) {
        new MyClass();
    }
}

class Person{
    static{
        System.out.println(&amp;quot;person static&amp;quot;);
    }
    public Person(String str) {
        System.out.println(&amp;quot;person &amp;quot;+str);
    }
}


class MyClass extends Test {
    Person person = new Person(&amp;quot;MyClass&amp;quot;);
    static{
        System.out.println(&amp;quot;myclass static&amp;quot;);
    }

    public MyClass() {
        System.out.println(&amp;quot;myclass constructor&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;test static&lt;/code&gt;&lt;br&gt;&lt;code&gt;myclass static&lt;/code&gt;&lt;br&gt;&lt;code&gt;person static&lt;/code&gt;&lt;br&gt;&lt;code&gt;person Test&lt;/code&gt;&lt;br&gt;&lt;code&gt;test constructor&lt;/code&gt;&lt;br&gt;&lt;code&gt;person MyClass&lt;/code&gt;&lt;br&gt;&lt;code&gt;myclass constructor&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;这段代码的输出结果是什么？-1&quot;&gt;&lt;a href=&quot;#这段代码的输出结果是什么？-1&quot; class=&quot;headerlink&quot; title=&quot;这段代码的输出结果是什么？&quot;&gt;&lt;/a&gt;这段代码的输出结果是什么？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Test {

    static{
        System.out.println(&amp;quot;test static 1&amp;quot;);
    }
    public static void main(String[] args) {

    }

    static{
        System.out.println(&amp;quot;test static 2&amp;quot;);
    }
}     
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;test static 1&lt;/code&gt;&lt;br&gt;&lt;code&gt;test static 2&lt;/code&gt; &lt;/p&gt;
&lt;h2 id=&quot;抽象类和方法&quot;&gt;&lt;a href=&quot;#抽象类和方法&quot; class=&quot;headerlink&quot; title=&quot;抽象类和方法&quot;&gt;&lt;/a&gt;抽象类和方法&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h2&gt;&lt;p&gt;1) 在每个类文件中最多只允许出现一个public类&lt;/p&gt;
&lt;p&gt;2) 如果没有显示地定义构造器，则编译器会自动创建一个无参构造器，如果显示地定义
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java-io流知识点梳理</title>
    <link href="http://www.freefpp.com/2016/05/18/java-io%E6%B5%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <id>http://www.freefpp.com/2016/05/18/java-io流知识点梳理/</id>
    <published>2016-05-18T09:05:58.000Z</published>
    <updated>2016-05-18T09:05:58.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java线程知识点梳理</title>
    <link href="http://www.freefpp.com/2016/05/13/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.freefpp.com/2016/05/13/线程/</id>
    <published>2016-05-13T02:55:34.000Z</published>
    <updated>2016-05-18T08:46:08.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;操作系统中线程和进程的区别&quot;&gt;&lt;a href=&quot;#操作系统中线程和进程的区别&quot; class=&quot;headerlink&quot; title=&quot;操作系统中线程和进程的区别&quot;&gt;&lt;/a&gt;操作系统中线程和进程的区别&lt;/h2&gt;&lt;p&gt;简单来说，一个程序至少有一个进程，一个进程至少有一个线程。&lt;/p&gt;
&lt;h2 id=&quot;线程的创建&quot;&gt;&lt;a href=&quot;#线程的创建&quot; class=&quot;headerlink&quot; title=&quot;线程的创建&quot;&gt;&lt;/a&gt;线程的创建&lt;/h2&gt;&lt;p&gt;继承Thread类和使用Runnable接口。&lt;/p&gt;
&lt;h4 id=&quot;方法一：继承Thread类覆盖run方法&quot;&gt;&lt;a href=&quot;#方法一：继承Thread类覆盖run方法&quot; class=&quot;headerlink&quot; title=&quot;方法一：继承Thread类覆盖run方法&quot;&gt;&lt;/a&gt;方法一：继承Thread类覆盖run方法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Demo1 {
   public static void main(String[] args) {
     Thread1 thread1=new Thread1();
     thread1.start();
     for(int i=0;i&amp;lt;60;i++){
 System.out.println(Thread.currentThread().getName()+i);
      }
   }
}
   class Thread1 extends Thread{
      @Override
      public void run() {
         for (int i = 0; i &amp;lt; 60; i++) {
   System.out.println(Thread.currentThread().getName()+i);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;方法二：继承Thread类覆盖run方法&quot;&gt;&lt;a href=&quot;#方法二：继承Thread类覆盖run方法&quot; class=&quot;headerlink&quot; title=&quot;方法二：继承Thread类覆盖run方法&quot;&gt;&lt;/a&gt;方法二：继承Thread类覆盖run方法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class Demo2 {
   public static void main(String[] args){
     Thread2 d =new Thread2();
     Thread t = new Thread(d);
     t.start();
     for(int x=0;x&amp;lt;60;x++){
  System.out.println(Thread.currentThread().getName()+x);
       }
    }
}
    class Thread2 implements Runnable{
      @Override
      public void run(){
      for(int x=0;x&amp;lt;60;x++){
  System.out.println(Thread.currentThread().getName()+x);
       }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;线程的状态&quot;&gt;&lt;a href=&quot;#线程的状态&quot; class=&quot;headerlink&quot; title=&quot;线程的状态&quot;&gt;&lt;/a&gt;线程的状态&lt;/h2&gt;&lt;h4 id=&quot;一、状态&quot;&gt;&lt;a href=&quot;#一、状态&quot; class=&quot;headerlink&quot; title=&quot;一、状态&quot;&gt;&lt;/a&gt;一、状态&lt;/h4&gt;&lt;p&gt;1、新建状态(New) :创建一个线程对象。&lt;/p&gt;
&lt;p&gt;2、可运行状态(Runnable) :当线程有资格运行，但调度程度还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也可返回到可运行状态。&lt;/p&gt;
&lt;p&gt;3、运行状态(Running) :线程获取了cpu资源，执行程序代码。&lt;/p&gt;
&lt;p&gt;4、阻塞状态(Blocked) :线程因为某种原因，放弃cpu资源，暂时停止运行，当某件事件出现，可能返回可运行状态。&lt;/p&gt;
&lt;p&gt;阻塞的情况分三种 :&lt;br&gt;(一)、等待 :运行的线程执行wait()方法，JVM会把该线程放入等待池中。&lt;/p&gt;
&lt;p&gt;(二)、同步阻塞 :运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。&lt;/p&gt;
&lt;p&gt;(三)、其他阻塞 :运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。&lt;/p&gt;
&lt;p&gt;5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。&lt;/p&gt;
&lt;h4 id=&quot;二、常用函数说明&quot;&gt;&lt;a href=&quot;#二、常用函数说明&quot; class=&quot;headerlink&quot; title=&quot;二、常用函数说明&quot;&gt;&lt;/a&gt;二、常用函数说明&lt;/h4&gt;&lt;p&gt;1、join()、join(long millis)、join(long millis, int nanos)    &lt;/p&gt;
&lt;p&gt;在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Demo3 {
   public static void main(String[] args) {
  System.out.println(Thread.currentThread().getName() + &amp;quot; 线程运行开始!&amp;quot;);
        Thread3 a=new Thread3();
        a.start();
  System.out.println(Thread.currentThread().getName() + &amp;quot; 线程运行结束!&amp;quot;);

   }
}
class Thread3 extends Thread{
   @Override
   public void run() {
System.out.println(Thread.currentThread().getName() + &amp;quot; 线程运行开始!&amp;quot;);  
      for (int i = 0; i &amp;lt; 5; i++) {  
           System.out.println(&amp;quot;子线程&amp;quot;+Thread.currentThread().getName() + &amp;quot;运行 : &amp;quot; + i);  
        try {  
            sleep((int) Math.random() * 10);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
    System.out.println(Thread.currentThread().getName() + &amp;quot; 线程运行结束!&amp;quot;);  
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;main 线程运行开始!&lt;/code&gt;&lt;br&gt;&lt;code&gt;main 线程运行结束!&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-0 线程运行开始!&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 0&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 1&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 2&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 3&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 4&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-0 线程运行结束!&lt;/code&gt;        &lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public class Demo3 {
   public static void main(String[] args) {
  System.out.println(Thread.currentThread().getName() + &amp;quot; 线程运行开始!&amp;quot;);
        Thread3 a=new Thread3();
           a.start();
        a.jion();
System.out.println(Thread.currentThread().getName() + &amp;quot; 线程运行结束!&amp;quot;);
   }
}
class Thread3 extends Thread{
   @Override
   public void run() {
System.out.println(Thread.currentThread().getName() + &amp;quot; 线程运行开始!&amp;quot;);  
      for (int i = 0; i &amp;lt; 5; i++) {  
           System.out.println(&amp;quot;子线程&amp;quot;+Thread.currentThread().getName() + &amp;quot;运行 : &amp;quot; + i);  
        try {  
            sleep((int) Math.random() * 10);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
    System.out.println(Thread.currentThread().getName() + &amp;quot; 线程运行结束!&amp;quot;);  
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;main 线程运行开始!&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-0 线程运行开始!&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 0&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 1&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 2&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 3&lt;/code&gt;&lt;br&gt;&lt;code&gt;子线程Thread-0运行 : 4&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-0 线程运行结束!&lt;/code&gt;&lt;br&gt;&lt;code&gt;main 线程运行结束!&lt;/code&gt;&lt;br&gt;2、sleep(long millis)、    sleep(long millis, int nanos)&lt;/p&gt;
&lt;p&gt; 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），不会释放锁&lt;/p&gt;
&lt;p&gt;3、wait()、wait(long millis)、wait(long millis, int nanos)&lt;br&gt;notify()、notifyAll()&lt;/p&gt;
&lt;p&gt;① 调用某个对象的wait()方法，相当于让当前线程交出此对象的monitor，然后进入等待状态，等待后续再次获得此对象的锁&lt;/p&gt;
&lt;p&gt;② notify()方法能够唤醒一个正在等待该对象的monitor的线程，当有多个线程都在等待该对象的monitor的话，则只能唤醒其中一个线程，具体唤醒哪个线程则不得而知。&lt;/p&gt;
&lt;p&gt;③ 调用某个对象的notify()方法，当前线程也必须拥有这个对象的monitor，因此调用notify()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Demo4 {
   public static Object object = new Object();

   public static void main(String[] args) throws       Exception {
      Thread4 thread4 = new Thread4();
      Thread5 thread5 = new Thread5();

      thread4.start();

      try {
          Thread.sleep(200);
      } catch (InterruptedException e) {
          e.printStackTrace();
      }

      thread5.start();
 }

static class Thread4 extends Thread {
    @Override
    public void run() {
        synchronized (object) {
            try {
                object.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&amp;quot;线程&amp;quot; + Thread.currentThread().getName()
                    + &amp;quot;获取到了锁&amp;quot;);
        }
    }
}

static class Thread5 extends Thread {
    @Override
    public void run() {
        synchronized (object) {
            object.notify();
            System.out.println(&amp;quot;线程&amp;quot; + Thread.currentThread().getName()
                    + &amp;quot;调用了object.notify()&amp;quot;);
        }
        System.out
                .println(&amp;quot;线程&amp;quot; + Thread.currentThread().getName() + &amp;quot;释放了锁&amp;quot;);
    }
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;线程Thread-1调用了object.notify()&lt;/code&gt;&lt;br&gt;&lt;code&gt;线程Thread-1释放了锁&lt;/code&gt;&lt;br&gt;&lt;code&gt;线程Thread-0获取到了锁&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;生产者－消费者模型的实现&lt;/p&gt;
&lt;p&gt;在前面我们将了很多关于同步的问题，然而在现实中，需要线程之间的协作。比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Demo5 {
    private int queueSize=10;
    private PriorityQueue&amp;lt;Integer&amp;gt; queue = new PriorityQueue&amp;lt;Integer&amp;gt;(queueSize);
    public static void main(String[] args) {
        Demo5 test = new Demo5();
        Producer producer = test.new Producer();
        Consumer consumer = test.new Consumer();
        consumer.start();
        producer.start();

  }
  class Consumer extends Thread{
      @Override
    public void run() {
          consume();
    }
      private void  consume(){
          while(true){
              synchronized (queue) {
                while (queue.size()==0) {
                    try {
                        System.out.println(&amp;quot;队列空，等待数据&amp;quot;);
                        queue.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                queue.poll();
                queue.notify();
                System.out.println(&amp;quot;从队列取走一个元素，队列剩余&amp;quot;+queue.size()+&amp;quot;个元素&amp;quot;);
            }
          }

      }
  }

  class Producer extends Thread{
      @Override
    public void run() {
          produce();
    }
      private void  produce(){
          while (true) {
             synchronized (queue) {
                while (queue.size()==queueSize) {
                    try {
                        System.out.println(&amp;quot;队列满，等待有空余空间&amp;quot;);
                        queue.wait();
                    } catch (InterruptedException e) {

                        e.printStackTrace();
                    }
                }
                queue.offer(1);
                queue.notify();
                System.out.println(&amp;quot;向队列取中插入一个元素，队列剩余空间：&amp;quot;+queue.size());
            }

        }
      }

  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;队列满，等待有空余空间&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余9个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余8个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余7个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余6个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余5个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余4个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余3个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余2个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余1个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余0个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;队列空，等待数据&lt;/code&gt;&lt;br&gt;&lt;code&gt;向队列取中插入一个元素，队列剩余空间：1&lt;/code&gt;&lt;br&gt;&lt;code&gt;向队列取中插入一个元素，队列剩余空间：2&lt;/code&gt;&lt;br&gt;&lt;code&gt;向队列取中插入一个元素，队列剩余空间：3&lt;/code&gt;&lt;br&gt;&lt;code&gt;向队列取中插入一个元素，队列剩余空间：4&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余3个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余2个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余1个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;从队列取走一个元素，队列剩余0个元素&lt;/code&gt;&lt;br&gt;&lt;code&gt;队列空，等待数据&lt;/code&gt;    &lt;/p&gt;
&lt;p&gt;④ yield()&lt;/p&gt;
&lt;p&gt;让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。&lt;br&gt;yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，     yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。&lt;br&gt;不会释放锁&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Demo6 {
   public static void main(String[] args) {
       Thread6 a = new Thread6();  
       Thread6 b = new Thread6();  
        a.start();  
        b.start();
  }
}
class Thread6 extends Thread{
  @Override
  public void run() {
      for (int i = 0; i &amp;lt; 5; i++) {
           System.out.println(&amp;quot;&amp;quot; + Thread.currentThread().getName() + &amp;quot;-----&amp;quot; + i);    
              if (i ==3) {  
                Thread.yield();  
             }  

     }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Thread-1-----0&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-1-----1&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-1-----2&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-1-----3&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-0-----0&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-1-----4&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-0-----1&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-0-----2&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-0-----3&lt;/code&gt;&lt;br&gt;&lt;code&gt;Thread-0-----4&lt;/code&gt;           &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;操作系统中线程和进程的区别&quot;&gt;&lt;a href=&quot;#操作系统中线程和进程的区别&quot; class=&quot;headerlink&quot; title=&quot;操作系统中线程和进程的区别&quot;&gt;&lt;/a&gt;操作系统中线程和进程的区别&lt;/h2&gt;&lt;p&gt;简单来说，一个程序至少有一个进程，一个进程至少有一个
    
    </summary>
    
    
  </entry>
  
</feed>
